using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BasicWebServer.Server.Common
{
    public class ServiceCollection : IServiceCollection
    {
        // TOВА Е НАШИЯ inversion Of Control Kонтейнер

        // имаме нужда да си пазим въпросните типове (дифиниции или както и там се наричат), имаме нужда и от конструктор
        // Т -> това в Type (когато се говори за generic методи - описваме типовете с които работим) - може да ги кръщаваме
        // както си искаме - може да са "Т", "ТНаБатаТиХвърчилото", "ТБлаБла"... - целата е да има яснота (за удобство)

        // дикшинърито ще пази типове - затова и ключа и стойността са Type-ове
        private readonly Dictionary<Type, Type> services;

        public ServiceCollection()
        {
            services = new Dictionary<Type, Type>();
        }

        public IServiceCollection Add<TSercice, TImplementation>()
            where TSercice : class
            where TImplementation : TSercice
        {
            // ще добавим на typeof(TSercice) - typeof(TImplementation)
            // т.е. на този ключ ще имаме съответната стойност
            services[typeof(TSercice)] = typeof(TImplementation);

            // за да можем да правим чейнинг - трябва да връщаме същия тип!!!
            return this;
        }

        public IServiceCollection Add<TSercice>() where TSercice : class
        {
            return Add<TSercice, TSercice>();
            // използваме имплементациата на горния метод add
            // т.е. ако бъде подедено само едното -> в дикшинърито ще имаме едно и също за ключ и за стойност
            // т.е. така имаме конкретна инстанция без да я "вързваме" с някакъв интерфейс
        }

        public object CreateInstance(Type serviceType)
        {
            // това, което следва да направим, минава малко за cheat, но пък ще ни спести много писане
            // на практика ние инстанцираме неща, който не само наши. когато ползваме dependency injection би било добре ако
            // ги има всички инстанции вътре в контейнера, но на практика не е така (има разни стандартни класове, които със
            // сигурност ще ги збравим да ги добавим в контейнера (но те са депенденсита в нашата система)). затова 
            // inversion Of control контейнер-a трябва да има възможност малко да cheat-не, когато не е ясно какво точно трябва
            // да се ползва- затова правим така:
            if (services.ContainsKey(serviceType))  // проверяваме дали съществува ключа (типа, който искаме да създадем)
            {
                serviceType = services[serviceType];  // ако ключа съществува - вземаме съответната стойност от Дикшинърито
                // т.е ще вземем, това което реално трябва да се инстанцира - т.е. не типа, а реално това, което трябва да се
                // инстанцира
            }
            // ако нямаме такъв регистриран сървис - ще се наложи да хвърлим грешка, но
            // както казахме по-горе - имаме стандартни обекти, които все пак, не е лошо да могат да се инстъанцират без
            // да трябва да ги описваме в invertion of control контейнера
            else if (serviceType.IsInterface) // <-- ако нямаме такъв ключ, проверяваме дали е интерфейс. Това не трябва
                                              // да е реален клас. Ако е интерфейс ние неможем да го инстанцираме.
            {
                throw new InvalidOperationException($"Service {serviceType.FullName} is not registerd!");
            }

            // Вече няма значени дали това, което сме взели, идва от Дикшинърито или вземаме направо това, което е дошло
            // (и не е интерфейс), което е реална инстанция - можем да си го ползваме. Трабва да го инстанциране.
            // Въпроса е, че неможем просто CretaeInstance.Activator.Bla.Bla - защото трябва да намерим и неговите параметри
            // т.е. преди да го създадем, трябва да му създадем всички негови зависимости... усеща ли се рекурсията?
            // - създаваме един, но трябва да създадем и неговите зависимости - които може би и те имат някакви зависимости
            //   и ще се налага да се влиза "обхожда" много на дълбоко. - трябва да се обходи рекурсивно, защото реално имаме
            //   дърво - а дърветата се обхождат с рекурсия.
            var constructors = serviceType.GetConstructors();
            // Тук има един малък проблем, когато се работи с dependency injection - inversion Of control контейнер-a няма как
            // сам да избере кой от овърлодите на конструкторите да ползва. Затова, при ползваме inversion Of control контейнер
            // ползваме един конструктор.
            // По принцип решенията са 1. Да се хвърли ексепшън, ако се срещне обект с повече от един конструктор и 2. да се
            // взема винаги първия, като се подведят по броя на параметрите в конструкторите за да инстанцираме колкото се
            // може по-малко. В тази връзка казваме:
            if (constructors.Length > 1)
            {
                throw new InvalidOperationException($"Multiple constructors are not supported");
            }

            // понеже constructors е колекция, трябва да си вземем конструктура с който ще работим. Вземаме първия конструктор
            var constructor = constructors[0];
            // след това трябва да вземем всички параметри на този конструктор
            var parameterts = constructor.GetParameters();
            // трябва да запазим стойностите на тези параметри. (когато се инстанцира с рефлекшън може да подадем един масив 
            // object с параметри. Масива е голям колкото броя на параметрите - затова е [parameterts.Length]
            var parameterValues = new object[parameterts.Length];

            for (int i = 0; i < parameterValues.Length; i++)
            {
                // тип на параметъра:
                var parameterType = parameterts[i].ParameterType;
                // даваме стойност на въпросния параметър. Алгоритъма е рекурсивен => т.е. рекурсивно минаваме и ги създаваме
                // всичките параметри
                var parameterValue = CreateInstance(parameterType);

                parameterValues[i] = parameterValue;
            }

            // след като сме попълнили съответните параметри - можем да създадем инстанцията -> т.е. извикваме конструктора
            return constructor.Invoke(parameterValues);
        }

        // как връщаме самата инстанция (сървис) ако някой ни я поиска. Тук се ползваме generic type => типа на TService
        // можем да си го получим с оператора typeof.
        public TService Get<TService>() where TService : class
        {
            var serviceType = typeof(TService);

            // Когато някой поиска експлицитно да получи от нас (с ГЕТ) конкретна инстанция от inversion Of control контейнер-a
            // вече е задължително тази инстанция да е описана (иначе той от къде знае, че я има за да я иска)
            // ако тази инстанция не съществува - логично е да трябва да се хърли ексепшън. НО inversion Of control контейнерите
            // нерабитят така (да хвърлят грешки). Би било лошо ако хвърлим ексепшън тук - затова понеже service-a е клас
            // ще върнем дефолтната за класа стойност (което е нулл). Чак после ще имаме гърмеж, когато (ако) се опитаме да го
            // ползваме.
            if (!services.ContainsKey(serviceType))
            {
                return null;
            }

            // ако го имаме -> ще трябва да създадем съответната имлементация
            var servise = services[serviceType];
            // създаването е така: !!! трябва да върнем TService, a нашия CreateInstance e object (за да може да върне
            // абсолютно всичко)
            return (TService)CreateInstance(servise);
        }
    }
}
